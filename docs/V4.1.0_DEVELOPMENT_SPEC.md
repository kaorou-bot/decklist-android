# v4.1.0 è¯¦ç»†å¼€å‘è§„èŒƒ - å¯¼å‡ºä¸æœç´¢åŠŸèƒ½

> æœ¬æ–‡æ¡£æä¾› v4.1.0 ç‰ˆæœ¬çš„è¯¦ç»†å¼€å‘è§„èŒƒã€æ¥å£è®¾è®¡å’Œå®ç°ç»†èŠ‚

---

## ğŸ“¦ æ¨¡å— 1.1ï¼šå¥—ç‰Œå¯¼å‡ºåŠŸèƒ½

### 1.1.1 æ¶æ„è®¾è®¡

#### æ–‡ä»¶ç»“æ„
```
app/src/main/java/com/mtgo/decklistmanager/
â”œâ”€â”€ exporter/
â”‚   â”œâ”€â”€ DecklistExporter.kt          # å¯¼å‡ºå™¨æ¥å£
â”‚   â”œâ”€â”€ format/
â”‚   â”‚   â”œâ”€â”€ MtgoFormatExporter.kt    # MTGO æ ¼å¼
â”‚   â”‚   â”œâ”€â”€ ArenaFormatExporter.kt   # Arena æ ¼å¼
â”‚   â”‚   â””â”€â”€ TextFormatExporter.kt    # æ–‡æœ¬æ ¼å¼
â”‚   â””â”€â”€ share/
â”‚       â”œâ”€â”€ MoxfieldShareGenerator.kt # Moxfield åˆ†äº«
â”‚       â””â”€â”€ ClipboardHelper.kt       # å‰ªè´´æ¿å·¥å…·
```

#### æ¥å£è®¾è®¡
```kotlin
/**
 * å¥—ç‰Œå¯¼å‡ºå™¨æ¥å£
 */
interface DecklistExporter {
    /**
     * å¯¼å‡ºå¥—ç‰Œ
     * @param decklist å¥—ç‰Œæ•°æ®
     * @param includeSideboard æ˜¯å¦åŒ…å«å¤‡ç‰Œ
     * @return å¯¼å‡ºçš„å­—ç¬¦ä¸²å†…å®¹
     */
    suspend fun export(
        decklist: Decklist,
        includeSideboard: Boolean = true
    ): String

    /**
     * è·å–æ–‡ä»¶æ‰©å±•å
     */
    fun getFileExtension(): String

    /**
     * è·å–æ ¼å¼åç§°
     */
    fun getFormatName(): String
}

/**
 * å¯¼å‡ºç»“æœ
 */
data class ExportResult(
    val content: String,
    val fileName: String,
    val formatName: String,
    val fileSize: Int
)
```

---

### 1.1.2 MTGO æ ¼å¼å¯¼å‡ºå™¨

#### æ ¼å¼è§„èŒƒ
```text
// MTGO .dek æ ¼å¼ç¤ºä¾‹
4 Bolt
2 Counterspell
1 Black Lotus

Sideboard
2 Red Elemental Blast
1 Blue Elemental Blast
```

#### å®ç°ä»£ç 
```kotlin
/**
 * MTGO .dek æ ¼å¼å¯¼å‡ºå™¨
 */
class MtgoFormatExporter @Inject constructor() : DecklistExporter {

    override suspend fun export(
        decklist: Decklist,
        includeSideboard: Boolean
    ): String {
        return buildString {
            // ä¸»ç‰Œ
            val mainDeck = decklist.cards.filter { it.location == "main" }
            mainDeck.forEach { card ->
                val cardName = card.cardNameZh ?: card.cardName
                line("${card.quantity} $cardName")
            }

            // å¤‡ç‰Œ
            if (includeSideboard) {
                val sideboard = decklist.cards.filter { it.location == "sideboard" }
                if (sideboard.isNotEmpty()) {
                    line()
                    line("Sideboard")
                    sideboard.forEach { card ->
                        val cardName = card.cardNameZh ?: card.cardName
                        line("${card.quantity} $cardName")
                    }
                }
            }
        }.trimEnd()
    }

    override fun getFileExtension() = "dek"

    override fun getFormatName() = "MTGO (.dek)"

    private fun StringBuilder.line(str: String = "") {
        appendLine(str)
    }
}
```

---

### 1.1.3 Arena æ ¼å¼å¯¼å‡ºå™¨

#### æ ¼å¼è§„èŒƒ
```json
{
  "name": "å¥—ç‰Œåç§°",
  "format": "Standard",
  "mainDeck": [
    {"id": "12345", "quantity": 4},
    {"id": "67890", "quantity": 2}
  ],
  "sideboard": [
    {"id": "11111", "quantity": 2}
  ]
}
```

#### å®ç°ä»£ç 
```kotlin
/**
 * MTGA Arena .json æ ¼å¼å¯¼å‡ºå™¨
 */
class ArenaFormatExporter @Inject constructor(
    private val repository: DecklistRepository
) : DecklistExporter {

    override suspend fun export(
        decklist: Decklist,
        includeSideboard: Boolean
    ): String {
        // éœ€è¦è·å– Scryfall ID
        val mainDeck = decklist.cards
            .filter { it.location == "main" }
            .map { card ->
                val cardInfo = repository.getCardInfo(card.cardName)
                ArenaCardEntry(
                    id = cardInfo?.scryfallId ?: "",
                    quantity = card.quantity
                )
            }

        val sideboard = if (includeSideboard) {
            decklist.cards
                .filter { it.location == "sideboard" }
                .map { card ->
                    val cardInfo = repository.getCardInfo(card.cardName)
                    ArenaCardEntry(
                        id = cardInfo?.scryfallId ?: "",
                        quantity = card.quantity
                    )
                }
        } else emptyList()

        val arenaDeck = ArenaDeck(
            name = decklist.deckName,
            format = decklist.format ?: "Standard",
            mainDeck = mainDeck,
            sideboard = sideboard
        )

        return Gson().toJson(arenaDeck)
    }

    override fun getFileExtension() = "json"

    override fun getFormatName() = "Arena (.json)"
}

data class ArenaDeck(
    val name: String,
    val format: String,
    val mainDeck: List<ArenaCardEntry>,
    val sideboard: List<ArenaCardEntry>
)

data class ArenaCardEntry(
    val id: String,
    val quantity: Int
)
```

---

### 1.1.4 Moxfield åˆ†äº«é“¾æ¥ç”Ÿæˆå™¨

#### å®ç°ä»£ç 
```kotlin
/**
 * Moxfield åˆ†äº«é“¾æ¥ç”Ÿæˆå™¨
 *
 * Moxfield API: https://www.moxfield.com/tools/bulk-import
 */
class MoxfieldShareGenerator @Inject constructor() {

    suspend fun generateShareLink(decklist: Decklist): String {
        // å°†å¥—ç‰Œè½¬æ¢ä¸º Moxfield æ ¼å¼
        val decklistText = convertToMoxfieldFormat(decklist)

        // URL ç¼–ç 
        val encoded = URLEncoder.encode(decklistText, "UTF-8")

        // ç”Ÿæˆåˆ†äº«é“¾æ¥
        return "https://www.moxfield.com/import?deck=$encoded"
    }

    private fun convertToMoxfieldFormat(decklist: Decklist): String {
        return buildString {
            val mainDeck = decklist.cards.filter { it.location == "main" }
            mainDeck.forEach { card ->
                val cardName = card.cardNameZh ?: card.cardName
                line("${card.quantity} $cardName")
            }

            val sideboard = decklist.cards.filter { it.location == "sideboard" }
            if (sideboard.isNotEmpty()) {
                line()
                sideboard.forEach { card ->
                    val cardName = card.cardNameZh ?: card.cardName
                    line("${card.quantity} $cardName")
                }
            }
        }.trimEnd()
    }

    private fun StringBuilder.line(str: String = "") {
        appendLine(str)
    }
}
```

---

### 1.1.5 UI å®ç°

#### DeckDetailActivity æ·»åŠ å¯¼å‡ºèœå•

```xml
<!-- res/menu/deck_detail_menu.xml -->
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <item
        android:id="@+id/action_export"
        android:icon="@drawable/ic_export"
        android:title="@string/export"
        app:showAsAction="ifRoom" />

    <item
        android:id="@+id/action_share"
        android:icon="@drawable/ic_share"
        android:title="@string/share"
        app:showAsAction="ifRoom" />
</menu>
```

#### å¯¼å‡ºæ ¼å¼é€‰æ‹©å¯¹è¯æ¡†

```kotlin
/**
 * å¯¼å‡ºæ ¼å¼é€‰æ‹©å¯¹è¯æ¡†
 */
class ExportFormatDialog : BottomSheetDialogFragment() {

    private var _binding: DialogExportFormatBinding? = null
    private val binding get() = _binding!!

    private val viewModel: DeckDetailViewModel by viewModels()

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = DialogExportFormatBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        setupClickListeners()
    }

    private fun setupClickListeners() {
        // MTGO æ ¼å¼
        binding.btnExportMtgo.setOnClickListener {
            viewModel.exportDecklist(ExportFormat.MTGO)
            dismiss()
        }

        // Arena æ ¼å¼
        binding.btnExportArena.setOnClickListener {
            viewModel.exportDecklist(ExportFormat.ARENA)
            dismiss()
        }

        // æ–‡æœ¬æ ¼å¼
        binding.btnExportText.setOnClickListener {
            viewModel.exportDecklist(ExportFormat.TEXT)
            dismiss()
        }

        // Moxfield é“¾æ¥
        binding.btnShareMoxfield.setOnClickListener {
            viewModel.generateMoxfieldLink()
            dismiss()
        }

        // å¤åˆ¶åˆ°å‰ªè´´æ¿
        binding.btnCopyClipboard.setOnClickListener {
            viewModel.copyToClipboard()
            dismiss()
        }
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }

    enum class ExportFormat {
        MTGO, ARENA, TEXT, MOXFIELD
    }

    companion object {
        const val TAG = "ExportFormatDialog"

        fun show(fragmentManager: FragmentManager) {
            ExportFormatDialog().show(fragmentManager, TAG)
        }
    }
}
```

#### DeckDetailViewModel æ·»åŠ å¯¼å‡ºé€»è¾‘

```kotlin
@HiltViewModel
class DeckDetailViewModel @Inject constructor(
    private val repository: DecklistRepository,
    private val mtgoExporter: MtgoFormatExporter,
    private val arenaExporter: ArenaFormatExporter,
    private val textExporter: TextFormatExporter,
    private val moxfieldGenerator: MoxfieldShareGenerator
) : ViewModel() {

    private val _exportResult = MutableSharedFlow<ExportResult>()
    val exportResult: SharedFlow<ExportResult> = _exportResult

    private val _moxfieldLink = MutableSharedFlow<String>()
    val moxfieldLink: SharedFlow<String> = _moxfieldLink

    /**
     * å¯¼å‡ºå¥—ç‰Œ
     */
    suspend fun exportDecklist(format: ExportFormatDialog.ExportFormat) {
        val decklist = currentDecklist.value ?: return

        val exporter = when (format) {
            ExportFormatDialog.ExportFormat.MTGO -> mtgoExporter
            ExportFormatDialog.ExportFormat.ARENA -> arenaExporter
            ExportFormatDialog.ExportFormat.TEXT -> textExporter
            else -> return
        }

        val content = exporter.export(decklist, includeSideboard = true)

        val result = ExportResult(
            content = content,
            fileName = "${decklist.deckName}.${exporter.getFileExtension()}",
            formatName = exporter.getFormatName(),
            fileSize = content.length
        )

        _exportResult.emit(result)
    }

    /**
     * ç”Ÿæˆ Moxfield åˆ†äº«é“¾æ¥
     */
    suspend fun generateMoxfieldLink() {
        val decklist = currentDecklist.value ?: return
        val link = moxfieldGenerator.generateShareLink(decklist)
        _moxfieldLink.emit(link)
    }

    /**
     * å¤åˆ¶åˆ°å‰ªè´´æ¿
     */
    suspend fun copyToClipboard(context: Context) {
        val decklist = currentDecklist.value ?: return
        val content = textExporter.export(decklist, includeSideboard = true)

        val clipboard = context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
        val clip = ClipData.newPlainText("Decklist", content)
        clipboard.setPrimaryClip(clip)

        _message.emit("å·²å¤åˆ¶åˆ°å‰ªè´´æ¿")
    }
}
```

---

### 1.1.6 æ–‡ä»¶ä¿å­˜åŠŸèƒ½

```kotlin
/**
 * æ–‡ä»¶ä¿å­˜å·¥å…·
 */
class FileSaver @Inject constructor(
    private val context: Context
) {

    /**
     * ä¿å­˜æ–‡ä»¶åˆ°æœ¬åœ°å­˜å‚¨
     */
    fun saveFile(fileName: String, content: String): Uri? {
        // æ£€æŸ¥å­˜å‚¨æƒé™
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            // Android 10+ ä½¿ç”¨ MediaStore
            return saveFileWithMediaStore(fileName, content)
        } else {
            // Android 9- ä½¿ç”¨ä¼ ç»Ÿæ–‡ä»¶æ“ä½œ
            return saveFileTraditionally(fileName, content)
        }
    }

    @RequiresApi(Build.VERSION_CODES.Q)
    private fun saveFileWithMediaStore(fileName: String, content: String): Uri? {
        val resolver = context.contentResolver

        val contentValues = ContentValues().apply {
            put(MediaStore.Files.FileColumns.DISPLAY_NAME, fileName)
            put(MediaStore.Files.FileColumns.MIME_TYPE, "text/plain")
            put(MediaStore.Files.FileColumns.RELATIVE_PATH,
                Environment.DIRECTORY_DOWNLOADS + "/DecklistManager/")
        }

        val uri = resolver.insert(MediaStore.Files.getContentUri("external"), contentValues)
        return uri?.let {
            resolver.openOutputStream(it)?.use { outputStream ->
                outputStream.write(content.toByteArray())
            }
            it
        }
    }

    private fun saveFileTraditionally(fileName: String, content: String): Uri? {
        val downloadsDir =
            Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS)
        val decklistDir = File(downloadsDir, "DecklistManager")

        if (!decklistDir.exists()) {
            decklistDir.mkdirs()
        }

        val file = File(decklistDir, fileName)
        return try {
            file.writeText(content)
            Uri.fromFile(file)
        } catch (e: Exception) {
            AppLogger.e("Failed to save file", e)
            null
        }
    }
}
```

---

### 1.1.7 åˆ†äº«åŠŸèƒ½

```kotlin
/**
 * åˆ†äº«å·¥å…·
 */
class ShareHelper @Inject constructor(
    private val context: Context
) {

    /**
     * åˆ†äº«æ–‡æœ¬
     */
    fun shareText(text: String, title: String = "åˆ†äº«å¥—ç‰Œ") {
        val intent = Intent(Intent.ACTION_SEND).apply {
            type = "text/plain"
            putExtra(Intent.EXTRA_TEXT, text)
            addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
        }

        // åˆ›å»ºé€‰æ‹©å™¨
        val chooser = Intent.createChooser(intent, title)
        context.startActivity(chooser)
    }

    /**
     * åˆ†äº«æ–‡ä»¶
     */
    fun shareFile(uri: Uri, title: String = "åˆ†äº«å¥—ç‰Œ") {
        val intent = Intent(Intent.ACTION_SEND).apply {
            type = context.contentResolver.getType(uri)
            putExtra(Intent.EXTRA_STREAM, uri)
            addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
        }

        val chooser = Intent.createChooser(intent, title)
        context.startActivity(chooser)
    }

    /**
     * åˆ†äº«åˆ°å¾®ä¿¡
     */
    fun shareToWeChat(text: String): Boolean {
        return try {
            val intent = Intent().apply {
                action = Intent.ACTION_SEND
                putExtra(Intent.EXTRA_TEXT, text)
                type = "text/plain"
                setPackage("com.tencent.mm") // å¾®ä¿¡åŒ…å
            }
            context.startActivity(intent)
            true
        } catch (e: Exception) {
            AppLogger.e("WeChat not installed", e)
            false
        }
    }

    /**
     * åˆ†äº«åˆ° QQ
     */
    fun shareToQQ(text: String): Boolean {
        return try {
            val intent = Intent().apply {
                action = Intent.ACTION_SEND
                putExtra(Intent.EXTRA_TEXT, text)
                type = "text/plain"
                setPackage("com.tencent.mobileqq") // QQåŒ…å
            }
            context.startActivity(intent)
            true
        } catch (e: Exception) {
            AppLogger.e("QQ not installed", e)
            false
        }
    }
}
```

---

## ğŸ“¦ æ¨¡å— 1.2ï¼šå¡ç‰Œæœç´¢åŠŸèƒ½

### 1.2.1 æ¶æ„è®¾è®¡

#### æ–‡ä»¶ç»“æ„
```
app/src/main/java/com/mtgo/decklistmanager/
â”œâ”€â”€ search/
â”‚   â”œâ”€â”€ SearchActivity.kt              # æœç´¢ç•Œé¢
â”‚   â”œâ”€â”€ SearchViewModel.kt             # æœç´¢ ViewModel
â”‚   â”œâ”€â”€ SearchAdapter.kt               # æœç´¢ç»“æœé€‚é…å™¨
â”‚   â”œâ”€â”€ filter/
â”‚   â”‚   â”œâ”€â”€ SearchFilterDialog.kt      # ç­›é€‰å¯¹è¯æ¡†
â”‚   â”‚   â”œâ”€â”€ ColorFilterView.kt         # é¢œè‰²ç­›é€‰è§†å›¾
â”‚   â”‚   â””â”€â”€ CmcRangeFilterView.kt      # æ³•æœ¯åŠ›å€¼èŒƒå›´è§†å›¾
â”‚   â””â”€â”€ history/
â”‚       â”œâ”€â”€ SearchHistoryManager.kt    # æœç´¢å†å²ç®¡ç†
â”‚       â””â”€â”€ SearchHistoryAdapter.kt    # å†å²è®°å½•é€‚é…å™¨
```

#### æ•°æ®åº“è®¾è®¡

```sql
-- æœç´¢å†å²è¡¨
CREATE TABLE search_history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    query TEXT NOT NULL,                -- æœç´¢å…³é”®è¯
    filter_json TEXT,                   -- ç­›é€‰æ¡ä»¶ï¼ˆJSONï¼‰
    timestamp INTEGER NOT NULL,         -- æœç´¢æ—¶é—´æˆ³
    result_count INTEGER                -- ç»“æœæ•°é‡
);

CREATE INDEX idx_search_history_timestamp
ON search_history(timestamp DESC);
```

```kotlin
/**
 * æœç´¢å†å²å®ä½“
 */
@Entity(tableName = "search_history")
data class SearchHistoryEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,

    val query: String,

    @ColumnInfo(name = "filter_json")
    val filterJson: String?,

    val timestamp: Long,

    @ColumnInfo(name = "result_count")
    val resultCount: Int
)

/**
 * DAO
 */
@Dao
interface SearchHistoryDao {
    @Query("SELECT * FROM search_history ORDER BY timestamp DESC LIMIT 20")
    suspend fun getRecentSearches(limit: Int = 20): List<SearchHistoryEntity>

    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(history: SearchHistoryEntity)

    @Delete
    suspend fun delete(history: SearchHistoryEntity)

    @Query("DELETE FROM search_history")
    suspend fun clearAll()

    @Query("DELETE FROM search_history WHERE id = :id")
    suspend fun deleteById(id: Long)
}
```

---

### 1.2.2 æœç´¢ç­›é€‰æ¡ä»¶

```kotlin
/**
 * æœç´¢ç­›é€‰æ¡ä»¶
 */
data class SearchFilter(
    // é¢œè‰²ç­›é€‰ï¼ˆWUBRGï¼‰
    val colors: Set<ManaColor> = emptySet(),

    // æ³•æœ¯åŠ›å€¼èŒƒå›´
    val cmcRange: IntRange? = null,

    // å¡ç‰Œç±»å‹
    val cardTypes: Set<CardType> = emptySet(),

    // ç¨€æœ‰åº¦
    val rarities: Set<Rarity> = emptySet(),

    // èµ›åˆ¶åˆæ³•æ€§
    val legalities: Set<Format> = emptySet()
) {
    /**
     * æ˜¯å¦æœ‰ç­›é€‰æ¡ä»¶
     */
    fun hasActiveFilters(): Boolean {
        return colors.isNotEmpty() ||
               cmcRange != null ||
               cardTypes.isNotEmpty() ||
               rarities.isNotEmpty() ||
               legalities.isNotEmpty()
    }

    /**
     * è½¬æ¢ä¸º JSON
     */
    fun toJson(): String {
        return Gson().toJson(this)
    }

    companion object {
        /**
         * ä» JSON è§£æ
         */
        fun fromJson(json: String?): SearchFilter? {
            return try {
                Gson().fromJson(json, SearchFilter::class.java)
            } catch (e: Exception) {
                null
            }
        }
    }
}

/**
 * æ³•åŠ›é¢œè‰²
 */
enum class ManaColor(val symbol: String, val colorHex: String) {
    WHITE("W", "#F8F6D8"),
    BLUE("U", "#0E68AB"),
    BLACK("B", "#150B00"),
    RED("R", "#D3202A"),
    GREEN("G", "#00733E")
}

/**
 * å¡ç‰Œç±»å‹
 */
enum class CardType {
    CREATURE, INSTANT, SORCERY, ENCHANTMENT,
    ARTIFACT, PLANESWALKER, LAND, BATTLE
}

/**
 * ç¨€æœ‰åº¦
 */
enum class Rarity {
    COMMON, UNCOMMON, RARE, MYTHIC
}

/**
 * èµ›åˆ¶
 */
enum class Format {
    STANDARD, PIONEER, MODERN, LEGACY,
    VINTAGE, PAUPER, COMMANDER, PAUPER
}
```

---

### 1.2.3 SearchViewModel

```kotlin
@HiltViewModel
class SearchViewModel @Inject constructor(
    private val repository: DecklistRepository,
    private val searchHistoryDao: SearchHistoryDao
) : ViewModel() {

    // æœç´¢å…³é”®è¯
    private val _searchQuery = MutableStateFlow("")
    val searchQuery: StateFlow<String> = _searchQuery

    // æœç´¢ç»“æœ
    private val _searchResults = MutableStateFlow<List<CardInfo>>(emptyList())
    val searchResults: StateFlow<List<CardInfo>> = _searchResults

    // æœç´¢çŠ¶æ€
    private val _searchState = MutableStateFlow<SearchState>(SearchState.Idle)
    val searchState: StateFlow<SearchState> = _searchState

    // å½“å‰ç­›é€‰æ¡ä»¶
    private val _currentFilter = MutableStateFlow<SearchFilter?>(null)
    val currentFilter: StateFlow<SearchFilter?> = _currentFilter

    // æœç´¢å†å²
    val searchHistory: StateFlow<List<SearchHistoryEntity>> =
        searchHistoryDao.getRecentSearches().asStateFlow(emptyList())

    /**
     * æ›´æ–°æœç´¢å…³é”®è¯
     */
    fun updateQuery(query: String) {
        _searchQuery.value = query
    }

    /**
     * æ‰§è¡Œæœç´¢
     */
    fun search() {
        val query = _searchQuery.value.trim()
        if (query.isEmpty()) return

        viewModelScope.launch {
            _searchState.value = SearchState.Loading

            try {
                val filter = _currentFilter.value

                // è°ƒç”¨ API æœç´¢
                val results = withContext(Dispatchers.IO) {
                    repository.searchCards(
                        query = query,
                        filter = filter
                    )
                }

                _searchResults.value = results
                _searchState.value = SearchState.Success(results.size)

                // ä¿å­˜æœç´¢å†å²
                saveSearchHistory(query, filter, results.size)

            } catch (e: Exception) {
                AppLogger.e("Search failed", e)
                _searchState.value = SearchState.Error(e.message)
            }
        }
    }

    /**
     * åº”ç”¨ç­›é€‰æ¡ä»¶
     */
    fun applyFilter(filter: SearchFilter) {
        _currentFilter.value = if (filter.hasActiveFilters()) {
            filter
        } else {
            null
        }

        // é‡æ–°æœç´¢
        search()
    }

    /**
     * æ¸…é™¤ç­›é€‰
     */
    fun clearFilter() {
        _currentFilter.value = null
        search()
    }

    /**
     * ä¿å­˜æœç´¢å†å²
     */
    private suspend fun saveSearchHistory(
        query: String,
        filter: SearchFilter?,
        resultCount: Int
    ) {
        val history = SearchHistoryEntity(
            query = query,
            filterJson = filter?.toJson(),
            timestamp = System.currentTimeMillis(),
            resultCount = resultCount
        )

        searchHistoryDao.insert(history)
    }

    /**
     * æ¸…é™¤æœç´¢å†å²
     */
    suspend fun clearHistory() {
        searchHistoryDao.clearAll()
    }

    /**
     * ä»å†å²è®°å½•é‡æ–°æœç´¢
     */
    fun searchFromHistory(history: SearchHistoryEntity) {
        _searchQuery.value = history.query
        _currentFilter.value = SearchFilter.fromJson(history.filterJson)
        search()
    }
}

/**
 * æœç´¢çŠ¶æ€
 */
sealed class SearchState {
    object Idle : SearchState()
    object Loading : SearchState()
    data class Success(val count: Int) : SearchState()
    data class Error(val message: String?) : SearchState()
}
```

---

### 1.2.4 SearchActivity UI

```kotlin
/**
 * æœç´¢ç•Œé¢
 */
@AndroidEntryPoint
class SearchActivity : BaseActivity() {

    private val viewModel: SearchViewModel by viewModels()
    private lateinit var binding: ActivitySearchBinding
    private lateinit var searchAdapter: SearchAdapter

    private val searchDebounce = debounce<String>(delay = 500) { query ->
        viewModel.updateQuery(query)
        if (query.isNotEmpty()) {
            viewModel.search()
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivitySearchBinding.inflate(layoutInflater)
        setContentView(binding.root)

        setupToolbar()
        setupSearchView()
        setupRecyclerView()
        setupObservers()
        setupClickListeners()
    }

    private fun setupToolbar() {
        setSupportActionBar(binding.toolbar)
        supportActionBar?.setDisplayHomeAsUpEnabled(true)
        supportActionBar?.setHomeAsUpIndicator(R.drawable.ic_close)
    }

    private fun setupSearchView() {
        binding.searchView.setOnQueryTextListener(object : SearchView.OnQueryTextListener {
            override fun onQueryTextSubmit(query: String?): Boolean {
                query?.let { searchDebounce(it) }
                return true
            }

            override fun onQueryTextChange(newText: String?): Boolean {
                newText?.let { searchDebounce(it) }
                return true
            }
        })

        binding.searchView.requestFocus()
        showKeyboard()
    }

    private fun setupRecyclerView() {
        searchAdapter = SearchAdapter(
            onItemClick = { cardInfo ->
                openCardDetail(cardInfo)
            }
        )

        binding.rvSearchResults.apply {
            layoutManager = GridLayoutManager(this@SearchActivity, 3)
            adapter = searchAdapter
        }
    }

    private fun setupObservers() {
        lifecycleScope.launch {
            viewModel.searchResults.collect { results ->
                searchAdapter.submitList(results)

                // æ›´æ–°ç©ºçŠ¶æ€æ˜¾ç¤º
                if (results.isEmpty() && viewModel.searchState.value is SearchState.Success) {
                    binding.emptyState.visibility = View.VISIBLE
                    binding.emptyState.text = "æœªæ‰¾åˆ°ç›¸å…³å¡ç‰Œ"
                } else {
                    binding.emptyState.visibility = View.GONE
                }
            }
        }

        lifecycleScope.launch {
            viewModel.searchState.collect { state ->
                when (state) {
                    is SearchState.Loading -> {
                        binding.progressBar.visibility = View.VISIBLE
                        binding.emptyState.visibility = View.GONE
                    }
                    is SearchState.Success -> {
                        binding.progressBar.visibility = View.GONE
                    }
                    is SearchState.Error -> {
                        binding.progressBar.visibility = View.GONE
                        binding.emptyState.visibility = View.VISIBLE
                        binding.emptyState.text = "æœç´¢å¤±è´¥: ${state.message}"
                    }
                    else -> {}
                }
            }
        }
    }

    private fun setupClickListeners() {
        binding.btnFilter.setOnClickListener {
            showFilterDialog()
        }
    }

    private fun showFilterDialog() {
        SearchFilterDialog().apply {
            setOnFilterAppliedListener { filter ->
                viewModel.applyFilter(filter)
            }
        }.show(supportFragmentManager, "FilterDialog")
    }

    private fun openCardDetail(cardInfo: CardInfo) {
        val intent = CardDetailActivity.newIntent(this, cardInfo)
        startActivity(intent)
    }

    private fun showKeyboard() {
        val imm = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager
        imm.toggleSoftInput(InputMethodManager.SHOW_FORCED, 0)
    }

    private fun hideKeyboard() {
        val imm = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager
        imm.hideSoftInputFromWindow(binding.searchView.windowToken, 0)
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        if (item.itemId == android.R.id.home) {
            finish()
            return true
        }
        return super.onOptionsItemSelected(item)
    }

    override fun onDestroy() {
        super.onDestroy()
        hideKeyboard()
        _binding = null
    }
}

/**
 * é˜²æŠ–å·¥å…·å‡½æ•°
 */
fun <T> debounce(
    delay: Long = 300,
    coroutineScope: CoroutineScope,
    fn: (T) -> Unit
): (T) -> Unit {
    var job: Job? = null
    return { param: T ->
        job?.cancel()
        job = coroutineScope.launch {
            delay(delay)
            fn(param)
        }
    }
}
```

---

### 1.2.5 ç­›é€‰å¯¹è¯æ¡†

```kotlin
/**
 * æœç´¢ç­›é€‰å¯¹è¯æ¡†
 */
class SearchFilterDialog : BottomSheetDialogFragment() {

    private var _binding: DialogSearchFilterBinding? = null
    private val binding get() = _binding!!

    private val selectedColors = mutableSetOf<ManaColor>()
    private var cmcRange: IntRange? = null
    private val selectedTypes = mutableSetOf<CardType>()
    private val selectedRarities = mutableSetOf<Rarity>()

    private var onFilterAppliedListener: ((SearchFilter) -> Unit)? = null

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = DialogSearchFilterBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        setupColorFilter()
        setupCmcFilter()
        setupTypeFilter()
        setupRarityFilter()
        setupButtons()
    }

    private fun setupColorFilter() {
        binding.colorFilterView.setOnColorSelectedListener { color ->
            if (selectedColors.contains(color)) {
                selectedColors.remove(color)
            } else {
                selectedColors.add(color)
            }
        }
    }

    private fun setupCmcFilter() {
        binding.cmcRangeView.setOnRangeChangedListener { range ->
            cmcRange = range
        }
    }

    private fun setupTypeFilter() {
        // è®¾ç½®ç±»å‹ç­›é€‰
    }

    private fun setupRarityFilter() {
        // è®¾ç½®ç¨€æœ‰åº¦ç­›é€‰
    }

    private fun setupButtons() {
        binding.btnApply.setOnClickListener {
            val filter = SearchFilter(
                colors = selectedColors,
                cmcRange = cmcRange,
                cardTypes = selectedTypes,
                rarities = selectedRarities
            )
            onFilterAppliedListener?.invoke(filter)
            dismiss()
        }

        binding.btnReset.setOnClickListener {
            selectedColors.clear()
            cmcRange = null
            selectedTypes.clear()
            selectedRarities.clear()
            // é‡ç½® UI
        }
    }

    fun setOnFilterAppliedListener(listener: (SearchFilter) -> Unit) {
        onFilterAppliedListener = listener
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }

    companion object {
        const val TAG = "SearchFilterDialog"
    }
}
```

---

## ğŸ“‹ æµ‹è¯•æ¸…å•

### å¯¼å‡ºåŠŸèƒ½æµ‹è¯•
- [ ] MTGO æ ¼å¼å¯¼å‡ºæ­£ç¡®
- [ ] Arena æ ¼å¼å¯¼å‡ºæ­£ç¡®
- [ ] æ–‡æœ¬æ ¼å¼å¯¼å‡ºæ­£ç¡®
- [ ] Moxfield é“¾æ¥ç”Ÿæˆæ­£ç¡®
- [ ] æ–‡ä»¶ä¿å­˜æˆåŠŸ
- [ ] åˆ†äº«åŠŸèƒ½æ­£å¸¸
- [ ] å‰ªè´´æ¿å¤åˆ¶æˆåŠŸ

### æœç´¢åŠŸèƒ½æµ‹è¯•
- [ ] ä¸­æ–‡æœç´¢æ­£å¸¸
- [ ] è‹±æ–‡æœç´¢æ­£å¸¸
- [ ] æ¨¡ç³Šæœç´¢æ­£å¸¸
- [ ] é¢œè‰²ç­›é€‰æ­£å¸¸
- [ ] æ³•æœ¯åŠ›å€¼ç­›é€‰æ­£å¸¸
- [ ] ç±»å‹ç­›é€‰æ­£å¸¸
- [ ] ç¨€æœ‰åº¦ç­›é€‰æ­£å¸¸
- [ ] æœç´¢å†å²ä¿å­˜æ­£å¸¸
- [ ] æœç´¢æ€§èƒ½è‰¯å¥½ï¼ˆ< 1ç§’ï¼‰

---

## ğŸ“ æ³¨é‡Šå’Œæ–‡æ¡£

æ‰€æœ‰æ–°å¢ä»£ç å¿…é¡»åŒ…å«ï¼š
1. KDoc ç±»æ³¨é‡Š
2. å…³é”®æ–¹æ³•æ³¨é‡Š
3. å¤æ‚é€»è¾‘æ³¨é‡Š

---

**åˆ›å»ºæ—¥æœŸï¼š** 2026-01-31
**ç›®æ ‡ç‰ˆæœ¬ï¼š** v4.1.0
**é¢„è®¡å®Œæˆï¼š** 2 å‘¨
