# v4.2.0 è¯¦ç»†å¼€å‘è§„èŒƒ - å¥—ç‰Œåˆ†æåŠŸèƒ½

> æœ¬æ–‡æ¡£æä¾› v4.2.0 ç‰ˆæœ¬çš„è¯¦ç»†å¼€å‘è§„èŒƒã€æ¥å£è®¾è®¡å’Œå®ç°ç»†èŠ‚

---

## ğŸ“Š æ¨¡å— 2.1ï¼šæ³•æœ¯åŠ›æ›²çº¿

### 2.1.1 ä¾èµ–æ·»åŠ 

```gradle
// app/build.gradle
dependencies {
    // MPAndroidChart - å¼ºå¤§çš„å›¾è¡¨åº“
    implementation 'com.github.PhilJay:MPAndroidChart:v3.1.0'
}
```

### 2.1.2 æ¶æ„è®¾è®¡

#### æ–‡ä»¶ç»“æ„
```
app/src/main/java/com/mtgo/decklistmanager/
â”œâ”€â”€ analysis/
â”‚   â”œâ”€â”€ analyzer/
â”‚   â”‚   â”œâ”€â”€ ManaCurveAnalyzer.kt       # æ³•æœ¯åŠ›æ›²çº¿åˆ†æå™¨
â”‚   â”‚   â”œâ”€â”€ ColorDistributionAnalyzer.kt # é¢œè‰²åˆ†å¸ƒåˆ†æå™¨
â”‚   â”‚   â”œâ”€â”€ CardStatisticsAnalyzer.kt    # å•å¡ç»Ÿè®¡åˆ†æå™¨
â”‚   â”‚   â””â”€â”€ PriceAnalyzer.kt            # ä»·æ ¼åˆ†æå™¨
â”‚   â”œâ”€â”€ model/
â”‚   â”‚   â”œâ”€â”€ ManaCurveData.kt           # æ³•æœ¯åŠ›æ›²çº¿æ•°æ®
â”‚   â”‚   â”œâ”€â”€ ColorDistribution.kt       # é¢œè‰²åˆ†å¸ƒæ•°æ®
â”‚   â”‚   â””â”€â”€ StatisticsData.kt          # ç»Ÿè®¡æ•°æ®
â”‚   â””â”€â”€ ui/
â”‚       â”œâ”€â”€ ManaCurveFragment.kt       # æ³•æœ¯åŠ›æ›²çº¿ç•Œé¢
â”‚       â”œâ”€â”€ ColorDistributionFragment.kt
â”‚       â””â”€â”€ StatisticsFragment.kt
```

---

### 2.1.3 æ³•æœ¯åŠ›æ›²çº¿åˆ†æå™¨

#### æ•°æ®æ¨¡å‹

```kotlin
/**
 * æ³•æœ¯åŠ›æ›²çº¿æ•°æ®ç‚¹
 */
data class ManaCurvePoint(
    val cmc: Int,              // æ³•æœ¯åŠ›å€¼
    val count: Int,            // å¡ç‰Œæ•°é‡
    val cardNames: List<String> // å¡ç‰Œåç§°åˆ—è¡¨
)

/**
 * æ³•æœ¯åŠ›æ›²çº¿æ•°æ®
 */
data class ManaCurveData(
    val points: List<ManaCurvePoint>,
    val totalCards: Int,
    val averageCmc: Float,
    val maxCmc: Int
) {
    /**
     * è·å–æœ€å¤§çš„æ•°é‡ï¼ˆç”¨äº Y è½´ç¼©æ”¾ï¼‰
     */
    fun getMaxCount(): Int {
        return points.maxOfOrNull { it.count } ?: 0
    }

    /**
     * è·å–æ³•æœ¯åŠ›å€¼èŒƒå›´ï¼ˆç”¨äº X è½´ï¼‰
     */
    fun getCmcRange(): IntRange {
        val min = points.minOfOrNull { it.cmc } ?: 0
        val max = points.maxOfOrNull { it.cmc } ?: 0
        return min..max
    }
}
```

#### åˆ†æå™¨å®ç°

```kotlin
/**
 * æ³•æœ¯åŠ›æ›²çº¿åˆ†æå™¨
 *
 * åˆ†æå¥—ç‰Œçš„æ³•æœ¯åŠ›å€¼åˆ†å¸ƒ
 */
@Singleton
class ManaCurveAnalyzer @Inject constructor() {

    /**
     * åˆ†æä¸»ç‰Œçš„æ³•æœ¯åŠ›æ›²çº¿
     */
    suspend fun analyzeMainDeck(cards: List<Card>): ManaCurveData {
        val mainDeck = cards.filter { it.location == "main" }
        return analyze(mainDeck)
    }

    /**
     * åˆ†æå¥—ç‰Œçš„æ³•æœ¯åŠ›æ›²çº¿
     */
    suspend fun analyze(cards: List<Card>): ManaCurveData {
        return withContext(Dispatchers.Default) {
            // æŒ‰æ³•æœ¯åŠ›å€¼åˆ†ç»„
            val groupedCards = cards
                .filter { it.cmc != null } // è¿‡æ»¤æ‰æ²¡æœ‰ CMC çš„å¡ç‰Œï¼ˆå¦‚åœ°ç‰Œï¼‰
                .groupBy { it.cmc ?: 0 }

            // ç”Ÿæˆæ•°æ®ç‚¹
            val points = groupedCards.map { (cmc, cardList) ->
                ManaCurvePoint(
                    cmc = cmc,
                    count = cardList.sumOf { it.quantity },
                    cardNames = cardList.map { it.cardNameZh ?: it.cardName }
                )
            }.sortedBy { it.cmc }

            // è®¡ç®—ç»Ÿè®¡æ•°æ®
            val totalCards = cards.sumOf { it.quantity }
            val averageCmc = if (totalCards > 0) {
                cards.sumOf { (it.cmc ?: 0) * it.quantity } / totalCards.toFloat()
            } else 0f

            val maxCmc = points.maxOfOrNull { it.cmc } ?: 0

            ManaCurveData(
                points = points,
                totalCards = totalCards,
                averageCmc = averageCmc,
                maxCmc = maxCmc
            )
        }
    }

    /**
     * ç”Ÿæˆå»ºè®®
     */
    fun generateSuggestions(data: ManaCurveData): List<String> {
        val suggestions = mutableListOf<String>()

        // æ£€æŸ¥æ³•æœ¯åŠ›æ›²çº¿æ˜¯å¦å¹³æ»‘
        val maxCount = data.getMaxCount()
        val points = data.points

        // æ£€æŸ¥ 0 è´¹å¡ç‰Œæ•°é‡
        val zeroDropCount = points.find { it.cmc == 0 }?.count ?: 0
        if (zeroDropCount > 25) {
            suggestions.add("0 è´¹å¡ç‰Œè¿‡å¤šï¼ˆ$zeroDropCount å¼ ï¼‰ï¼Œå¯èƒ½ç¼ºä¹å¨èƒ")
        }

        // æ£€æŸ¥ 1 è´¹å¡ç‰Œæ•°é‡
        val oneDropCount = points.find { it.cmc == 1 }?.count ?: 0
        if (oneDropCount < 4 && data.averageCmc > 3) {
            suggestions.add("1 è´¹æ›²çº¿è¿‡å°‘ï¼Œå‰æœŸå¯èƒ½ç¼ºä¹äº’åŠ¨")
        }

        // æ£€æŸ¥é«˜è´¹å¡ç‰Œï¼ˆ>= 5ï¼‰
        val highDropCount = points
            .filter { it.cmc >= 5 }
            .sumOf { it.count }
        if (highDropCount > 15) {
            suggestions.add("é«˜è´¹å¡ç‰Œè¿‡å¤šï¼ˆ$highDropCount å¼ ï¼‰ï¼Œå¯èƒ½å¡æ‰‹")
        }

        // æ£€æŸ¥å¹³å‡æ³•æœ¯åŠ›å€¼
        when {
            data.averageCmc < 2.0 -> suggestions.add("å¹³å‡æ³•æœ¯åŠ›å€¼è¿‡ä½ï¼ˆ${"%.2f".format(data.averageCmc)}ï¼‰ï¼ŒåæœŸå¯èƒ½ä¹åŠ›")
            data.averageCmc > 3.5 -> suggestions.add("å¹³å‡æ³•æœ¯åŠ›å€¼è¿‡é«˜ï¼ˆ${"%.2f".format(data.averageCmc)}ï¼‰ï¼Œå®¹æ˜“å¡æ‰‹")
        }

        return suggestions
    }
}
```

---

### 2.1.4 æ³•æœ¯åŠ›æ›²çº¿ UI

#### ManaCurveFragment

```kotlin
/**
 * æ³•æœ¯åŠ›æ›²çº¿ç•Œé¢
 */
@AndroidEntryPoint
class ManaCurveFragment : Fragment() {

    private val viewModel: DeckDetailViewModel by viewModels()
    private var _binding: FragmentManaCurveBinding? = null
    private val binding get() = _binding!!

    private lateinit var barChart: BarChart

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentManaCurveBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        setupChart()
        observeData()
    }

    private fun setupChart() {
        barChart = binding.barChart

        // åŸºæœ¬é…ç½®
        barChart.apply {
            description.isEnabled = false
            legend.enabled = true
            setTouchEnabled(true)
            isDragEnabled = true
            setScaleEnabled(true)
            setPinchZoom(true)
            doubleTapToZoomEnabled = false

            // X è½´
            xAxis.apply {
                position = XAxis.XAxisPosition.BOTTOM
                setDrawGridLines(false)
                granularity = 1f
                valueFormatter = object : ValueFormatter() {
                    override fun getFormattedValue(value: Float): String {
                        return if (value >= 10) {
                            "${value.toInt()}+"
                        } else {
                            value.toInt().toString()
                        }
                    }
                }
            }

            // Y è½´
            axisLeft.apply {
                setDrawGridLines(true)
                axisMinimum = 0f
                granularity = 1f
            }

            axisRight.isEnabled = false

            // åŠ¨ç”»
            animateY(1000)
        }

        // è®¾ç½®ç‚¹å‡»ç›‘å¬
        barChart.setOnChartValueSelectedListener(object :
            OnChartValueSelectedListener {
            override fun onValueSelected(e: Entry, h: Highlight) {
                val cmc = e.x.toInt()
                showCardsForCmc(cmc)
            }

            override fun onNothingSelected() {
                // ä¸åšå¤„ç†
            }
        })
    }

    private fun observeData() {
        viewLifecycleOwner.lifecycleScope.launch {
            viewModel.manaCurveData.collect { data ->
                data?.let { updateChart(it) }
            }
        }

        viewLifecycleOwner.lifecycleScope.launch {
            viewModel.manaCurveSuggestions.collect { suggestions ->
                binding.tvSuggestions.text = suggestions.joinToString("\nâ€¢ ")
            }
        }
    }

    private fun updateChart(data: ManaCurveData) {
        val entries = data.points.map { point ->
            BarEntry(point.cmc.toFloat(), point.count.toFloat())
        }

        val dataSet = BarDataSet(entries, "å¡ç‰Œæ•°é‡").apply {
            colors = listOf(
                Color.parseColor("#4CAF50"), // 0-1 è´¹ï¼šç»¿è‰²
                Color.parseColor("#2196F3"), // 2-3 è´¹ï¼šè“è‰²
                Color.parseColor("#FF9800"), // 4-5 è´¹ï¼šæ©™è‰²
                Color.parseColor("#F44336")  // 6+ è´¹ï¼šçº¢è‰²
            )
            valueTextSize = 12f
            valueTextColor = Color.WHITE
        }

        val barData = BarData(dataSet).apply {
            barWidth = 0.6f
        }

        barChart.data = barData
        barChart.notifyDataSetChanged()
        barChart.invalidate()

        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        binding.tvTotalCards.text = "æ€»å¡ç‰Œ: ${data.totalCards}"
        binding.tvAverageCmc.text = "å¹³å‡æ³•æœ¯åŠ›å€¼: ${"%.2f".format(data.averageCmc)}"
    }

    private fun showCardsForCmc(cmc: Int) {
        viewModel.manaCurveData.value?.let { data ->
            val point = data.points.find { it.cmc == cmc }
            point?.let {
                val cardNames = it.cardNames.joinToString("\n")
                showDialog("CMC $cmc çš„å¡ç‰Œ", cardNames)
            }
        }
    }

    private fun showDialog(title: String, message: String) {
        AlertDialog.Builder(requireContext())
            .setTitle(title)
            .setMessage(message)
            .setPositiveButton("ç¡®å®š", null)
            .show()
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }

    companion object {
        fun newInstance() = ManaCurveFragment()
    }
}
```

#### å¸ƒå±€æ–‡ä»¶

```xml
<!-- res/layout/fragment_mana_curve.xml -->
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp">

    <!-- ç»Ÿè®¡ä¿¡æ¯ -->
    <LinearLayout
        android:id="@+id/layoutStats"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent">

        <TextView
            android:id="@+id/tvTotalCards"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="æ€»å¡ç‰Œ: 60"
            android:textSize="14sp" />

        <TextView
            android:id="@+id/tvAverageCmc"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="å¹³å‡æ³•æœ¯åŠ›å€¼: 2.50"
            android:textSize="14sp" />
    </LinearLayout>

    <!-- å›¾è¡¨ -->
    <com.github.mikephil.charting.charts.BarChart
        android:id="@+id/barChart"
        android:layout_width="0dp"
        android:layout_height="0dp"
        android:layout_marginTop="16dp"
        app:layout_constraintTop_toBottomOf="@id/layoutStats"
        app:layout_constraintBottom_toTopOf="@id/tvSuggestionsLabel"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent" />

    <!-- å»ºè®®æ ‡ç­¾ -->
    <TextView
        android:id="@+id/tvSuggestionsLabel"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="å»ºè®®ï¼š"
        android:textSize="16sp"
        android:textStyle="bold"
        android:layout_marginTop="16dp"
        app:layout_constraintTop_toBottomOf="@id/barChart"
        app:layout_constraintStart_toStartOf="parent" />

    <!-- å»ºè®®å†…å®¹ -->
    <TextView
        android:id="@+id/tvSuggestions"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_marginTop="8dp"
        android:text="â€¢ 1 è´¹æ›²çº¿è¿‡å°‘\nâ€¢ é«˜è´¹å¡ç‰Œè¿‡å¤š"
        android:textSize="14sp"
        app:layout_constraintTop_toBottomOf="@id/tvSuggestionsLabel"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintBottom_toBottomOf="parent" />

</androidx.constraintlayout.widget.ConstraintLayout>
```

---

## ğŸ¨ æ¨¡å— 2.2ï¼šé¢œè‰²åˆ†å¸ƒåˆ†æ

### 2.2.1 æ•°æ®æ¨¡å‹

```kotlin
/**
 * é¢œè‰²åˆ†å¸ƒæ•°æ®
 */
data class ColorDistribution(
    val white: Int = 0,
    val blue: Int = 0,
    val black: Int = 0,
    val red: Int = 0,
    val green: Int = 0,
    val colorless: Int = 0
) {
    /**
     * è·å–æ€»æ³•æœ¯åŠ›éœ€æ±‚æ•°
     */
    fun getTotalMana(): Int {
        return white + blue + black + red + green + colorless
    }

    /**
     * è·å–ç™¾åˆ†æ¯”åˆ†å¸ƒ
     */
    fun getPercentages(): Map<ManaColor, Float> {
        val total = getTotalMana()
        if (total == 0) return emptyMap()

        return mapOf(
            ManaColor.WHITE to white.toFloat() / total,
            ManaColor.BLUE to blue.toFloat() / total,
            ManaColor.BLACK to black.toFloat() / total,
            ManaColor.RED to red.toFloat() / total,
            ManaColor.GREEN to green.toFloat() / total,
            ManaColor.COLORLESS to colorless.toFloat() / total
        )
    }

    /**
     * è·å–æ’åºåçš„é¢œè‰²åˆ—è¡¨ï¼ˆæŒ‰éœ€æ±‚æ•°é‡é™åºï¼‰
     */
    fun getSortedColors(): List<Pair<ManaColor, Int>> {
        return listOf(
            ManaColor.WHITE to white,
            ManaColor.BLUE to blue,
            ManaColor.BLACK to black,
            ManaColor.RED to red,
            ManaColor.GREEN to green,
            ManaColor.COLORLESS to colorless
        ).sortedByDescending { it.second }
    }
}

/**
 * æ‰©å±•ï¼šæ·»åŠ  COLORLESS åˆ° ManaColor æšä¸¾
 */
enum class ManaColor(val symbol: String, val colorHex: String, val displayName: String) {
    WHITE("W", "#F8F6D8", "ç™½è‰²"),
    BLUE("U", "#0E68AB", "è“è‰²"),
    BLACK("B", "#150B00", "é»‘è‰²"),
    RED("R", "#D3202A", "çº¢è‰²"),
    GREEN("G", "#00733E", "ç»¿è‰²"),
    COLORLESS("C", "#9E9E9E", "æ— è‰²");
}
```

---

### 2.2.2 é¢œè‰²åˆ†å¸ƒåˆ†æå™¨

```kotlin
/**
 * é¢œè‰²åˆ†å¸ƒåˆ†æå™¨
 *
 * åˆ†æå¥—ç‰Œçš„æ³•æœ¯åŠ›é¢œè‰²éœ€æ±‚
 */
@Singleton
class ColorDistributionAnalyzer @Inject constructor(
    private val repository: DecklistRepository
) {

    /**
     * åˆ†æå¥—ç‰Œçš„é¢œè‰²åˆ†å¸ƒ
     */
    suspend fun analyze(cards: List<Card>): ColorDistribution {
        return withContext(Dispatchers.Default) {
            var white = 0
            var blue = 0
            var black = 0
            var red = 0
            var green = 0
            var colorless = 0

            cards.forEach { card ->
                // è·å–å¡ç‰Œè¯¦ç»†ä¿¡æ¯
                val cardInfo = repository.getCardInfo(card.cardName)

                cardInfo?.manaCost?.let { cost ->
                    // è§£ææ³•æœ¯åŠ›ç¬¦å·
                    val symbols = parseManaSymbols(cost)

                    symbols.forEach { symbol ->
                        when (symbol) {
                            "W" -> white += card.quantity
                            "U" -> blue += card.quantity
                            "B" -> black += card.quantity
                            "R" -> red += card.quantity
                            "G" -> green += card.quantity
                            else -> colorless += card.quantity
                        }
                    }
                }
            }

            ColorDistribution(
                white = white,
                blue = blue,
                black = black,
                red = red,
                green = green,
                colorless = colorless
            )
        }
    }

    /**
     * è§£ææ³•æœ¯åŠ›ç¬¦å·
     *
     * ç¤ºä¾‹ï¼š"{2}{U}{U}" -> ["2", "U", "U"]
     */
    private fun parseManaSymbols(manaCost: String): List<String> {
        val symbols = mutableListOf<String>()

        // åŒ¹é… {X} æ ¼å¼çš„ç¬¦å·
        val pattern = Pattern.compile("\\{([^}]+)\\}")
        val matcher = pattern.matcher(manaCost)

        while (matcher.find()) {
            val symbol = matcher.group(1)
            symbols.add(symbol)
        }

        return symbols
    }

    /**
     * ç”Ÿæˆå»ºè®®
     */
    fun generateSuggestions(
        distribution: ColorDistribution,
        totalLands: Map<ManaColor, Int>
    ): List<String> {
        val suggestions = mutableListOf<String>()

        val totalMana = distribution.getTotalMana()
        if (totalMana == 0) return suggestions

        val percentages = distribution.getPercentages()

        // æ£€æŸ¥åœ°ç‰Œæ¯”ä¾‹æ˜¯å¦åŒ¹é…æ³•æœ¯åŠ›éœ€æ±‚
        totalLands.forEach { (color, landCount) ->
            val expectedPercentage = percentages[color] ?: 0f
            val actualPercentage = landCount.toFloat() / totalLands.values.sum()

            val diff = abs(expectedPercentage - actualPercentage)
            if (diff > 0.1) { // å·®å¼‚è¶…è¿‡ 10%
                suggestions.add(
                    "${color.displayName}æ³•æœ¯åŠ›éœ€æ±‚ ${"%.0f".format(expectedPercentage * 100)}%ï¼Œ" +
                    "ä½†åœ°ç‰Œæ¯”ä¾‹ ${"%.0f".format(actualPercentage * 100)}%"
                )
            }
        }

        // æ£€æŸ¥æ˜¯å¦æ˜¯åŒè‰²å¥—ç‰Œä½†ä¸»è‰²ä¸æ˜ç¡®
        val sortedColors = distribution.getSortedColors()
        if (sortedColors.size >= 2) {
            val firstColor = sortedColors[0]
            val secondColor = sortedColors[1]

            if (firstColor.second < secondColor.second * 1.5) {
                suggestions.add(
                    "${firstColor.first.displayName}å’Œ${secondColor.first.displayName}æ¯”ä¾‹æ¥è¿‘ï¼Œ" +
                    "å¯èƒ½éœ€è¦è°ƒæ•´ä¼˜å…ˆçº§"
                )
            }
        }

        return suggestions
    }
}
```

---

### 2.2.3 é¥¼å›¾ UI

```kotlin
/**
 * é¢œè‰²åˆ†å¸ƒç•Œé¢
 */
@AndroidEntryPoint
class ColorDistributionFragment : Fragment() {

    private val viewModel: DeckDetailViewModel by viewModels()
    private var _binding: FragmentColorDistributionBinding? = null
    private val binding get() = _binding!!

    private lateinit var pieChart: PieChart

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentColorDistributionBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        setupPieChart()
        observeData()
    }

    private fun setupPieChart() {
        pieChart = binding.pieChart

        pieChart.apply {
            description.isEnabled = false
            legend.isEnabled = true
            legend.orientation = Legend.LegendOrientation.VERTICAL
            legend.horizontalAlignment = Legend.LegendHorizontalAlignment.RIGHT

            setUsePercentValues(true)
            setEntryLabelTextSize(12f)
            setEntryLabelColor(Color.WHITE)
            setHoleColor(Color.TRANSPARENT)
            setTransparentCircleColor(Color.TRANSPARENT)

            // åŠ¨ç”»
            animateY(1000)
        }
    }

    private fun observeData() {
        viewLifecycleOwner.lifecycleScope.launch {
            viewModel.colorDistribution.collect { distribution ->
                distribution?.let { updatePieChart(it) }
            }
        }
    }

    private fun updatePieChart(distribution: ColorDistribution) {
        val entries = mutableListOf<PieEntry>()

        if (distribution.white > 0) {
            entries.add(PieEntry(distribution.white.toFloat(), "ç™½è‰²"))
        }
        if (distribution.blue > 0) {
            entries.add(PieEntry(distribution.blue.toFloat(), "è“è‰²"))
        }
        if (distribution.black > 0) {
            entries.add(PieEntry(distribution.black.toFloat(), "é»‘è‰²"))
        }
        if (distribution.red > 0) {
            entries.add(PieEntry(distribution.red.toFloat(), "çº¢è‰²"))
        }
        if (distribution.green > 0) {
            entries.add(PieEntry(distribution.green.toFloat(), "ç»¿è‰²"))
        }
        if (distribution.colorless > 0) {
            entries.add(PieEntry(distribution.colorless.toFloat(), "æ— è‰²"))
        }

        val dataSet = PieDataSet(entries, "æ³•æœ¯åŠ›éœ€æ±‚").apply {
            colors = listOf(
                Color.parseColor("#F8F6D8"), // ç™½
                Color.parseColor("#0E68AB"), // è“
                Color.parseColor("#150B00"), // é»‘
                Color.parseColor("#D3202A"), // çº¢
                Color.parseColor("#00733E"), // ç»¿
                Color.parseColor("#9E9E9E")  // æ— è‰²
            )
            valueTextSize = 14f
            valueTextColor = Color.WHITE
        }

        val pieData = PieData(dataSet)
        pieChart.data = pieData
        pieChart.notifyDataSetChanged()
        pieChart.invalidate()
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }

    companion object {
        fun newInstance() = ColorDistributionFragment()
    }
}
```

---

## ğŸ’° æ¨¡å— 2.4ï¼šä»·æ ¼ä¼°ç®—

### 2.4.1 API é›†æˆ

#### CardMarket API é…ç½®

```kotlin
/**
 * CardMarket (MKM) API é…ç½®
 */
object CardMarketConfig {
    const val BASE_URL = "https://api.cardmarket.com/"
    const val APP_TOKEN = "your_app_token"
    const val APP_SECRET = "your_app_secret"

    // è¯·æ±‚é—´éš”é™åˆ¶ï¼ˆMKM è¦æ±‚ï¼‰
    const val REQUEST_INTERVAL_MS = 100L
}
```

#### API æ¥å£

```kotlin
/**
 * CardMarket API æœåŠ¡
 */
interface CardMarketApiService {
    /**
     * æŸ¥è¯¢å•å¡ä»·æ ¼
     */
    @GET("/ws/v2.0/output.json/products/{id}/priceguide")
    suspend fun getProductPriceGuide(
        @Path("id") productId: String,
        @Query("idLanguage") idLanguage: Int = 1 // 1 = English
    ): Response<CardMarketPriceGuide>

    /**
     * æœç´¢äº§å“
     */
    @GET("/ws/v2.0/output.json/products/find")
    suspend fun findProduct(
        @Query("search") search: String,
        @Query("idGame") idGame: Int = 1 // 1 = MTG
    ): Response<CardMarketProductSearchResponse>
}

/**
 * ä»·æ ¼æŒ‡å—å“åº”
 */
data class CardMarketPriceGuide(
    val product: CardMarketProduct,
    val priceGuide: CardMarketPriceData
)

data class CardMarketProduct(
    val idProduct: String,
    val enName: String,
    val localizedNames: List<CardMarketLocalizedName>?
)

data class CardMarketLocalizedName(
    val idLanguage: Int,
    val languageName: String
)

data class CardMarketPriceData(
    val sellMode: Int,
    val lowPrice: Double,
    val lowPriceExPlus: Double,
    lowPriceGood: Double,
    val lowPriceLight: Double,
    val avgPrice: Double,
    val avgPrice1: Double,
    val avgPrice7: Int,
    val avgPrice30: Int,
    val avgPrice180: Int,
    val trendPrice: Double,
    val suggestedPrice: Double,
    val foilAvgPrice: Double,
    val foilLowPrice: Double,
    val foilTrendPrice: Double,
    val germanProLow: Double,
    val germanPlayLow: Double
)
```

---

### 2.4.2 ä»·æ ¼åˆ†æå™¨

```kotlin
/**
 * ä»·æ ¼åˆ†æå™¨
 *
 * ä½¿ç”¨ CardMarket API è·å–å¥—ç‰Œä»·æ ¼
 */
@Singleton
class PriceAnalyzer @Inject constructor(
    private val cardMarketApi: CardMarketApiService,
    private val cardPriceDao: CardPriceDao
) {

    private val priceCache = mutableMapOf<String, CardPriceInfo>()
    private var lastRequestTime = 0L

    /**
     * åˆ†æå¥—ç‰Œæ€»ä»·
     */
    @OptIn(ExperimentalTime::class)
    suspend fun analyzeDeckPrice(cards: List<Card>): DeckPriceInfo {
        return withContext(Dispatchers.IO) {
            var totalPrice = 0.0
            val cardPrices = mutableListOf<CardPriceInfo>()

            cards.forEach { card ->
                // æ£€æŸ¥ç¼“å­˜
                val cachedPrice = priceCache[card.cardName]
                if (cachedPrice != null && isCacheValid(cachedPrice)) {
                    totalPrice += cachedPrice.price * card.quantity
                    cardPrices.add(cachedPrice)
                } else {
                    // ä» API è·å–ä»·æ ¼
                    val priceInfo = fetchCardPrice(card.cardName)
                    if (priceInfo != null) {
                        priceCache[card.cardName] = priceInfo
                        totalPrice += priceInfo.price * card.quantity
                        cardPrices.add(priceInfo)

                        // ä¿å­˜åˆ°æ•°æ®åº“
                        cardPriceDao.insert(CardPriceEntity(
                            cardName = card.cardName,
                            price = priceInfo.price,
                            timestamp = System.currentTimeMillis()
                        ))
                    }
                }

                // é™åˆ¶è¯·æ±‚é¢‘ç‡
                enforceRateLimit()
            }

            // æ’åºå¹¶å–å‰ 10 æœ€è´µçš„å¡
            val topExpensiveCards = cardPrices
                .sortedByDescending { it.price }
                .take(10)

            DeckPriceInfo(
                totalPrice = totalPrice,
                averageCardPrice = if (cards.isNotEmpty()) {
                    totalPrice / cards.sumOf { it.quantity }
                } else 0.0,
                topExpensiveCards = topExpensiveCards,
                currency = "EUR" // CardMarket ä½¿ç”¨æ¬§å…ƒ
            )
        }
    }

    /**
     * è·å–å•å¡ä»·æ ¼
     */
    private suspend fun fetchCardPrice(cardName: String): CardPriceInfo? {
        return try {
            // æœç´¢äº§å“
            val searchResponse = cardMarketApi.findProduct(cardName)
            if (!searchResponse.isSuccessful || searchResponse.body()?.product?.isEmpty() != false) {
                return null
            }

            val product = searchResponse.body()!!.product!![0]

            // è·å–ä»·æ ¼æŒ‡å—
            val priceGuideResponse = cardMarketApi.getProductPriceGuide(product.idProduct)
            if (!priceGuideResponse.isSuccessful) {
                return null
            }

            val priceGuide = priceGuideResponse.body()!!

            CardPriceInfo(
                cardName = cardName,
                price = priceGuide.priceGuide.avgPrice, // ä½¿ç”¨å¹³å‡ä»·æ ¼
                lowPrice = priceGuide.priceGuide.lowPrice,
                trendPrice = priceGuide.priceGuide.trendPrice,
                currency = "EUR",
                timestamp = System.currentTimeMillis()
            )

        } catch (e: Exception) {
            AppLogger.e("Failed to fetch price for $cardName", e)
            null
        }
    }

    /**
     * æ£€æŸ¥ç¼“å­˜æ˜¯å¦æœ‰æ•ˆï¼ˆ24 å°æ—¶ï¼‰
     */
    private fun isCacheValid(priceInfo: CardPriceInfo): Boolean {
        val cacheAge = System.currentTimeMillis() - priceInfo.timestamp
        return cacheAge < TimeUnit.DAYS.toMillis(1)
    }

    /**
     * é™åˆ¶è¯·æ±‚é¢‘ç‡
     */
    private suspend fun enforceRateLimit() {
        val currentTime = System.currentTimeMillis()
        val timeSinceLastRequest = currentTime - lastRequestTime

        if (timeSinceLastRequest < CardMarketConfig.REQUEST_INTERVAL_MS) {
            delay(CardMarketConfig.REQUEST_INTERVAL_MS - timeSinceLastRequest)
        }

        lastRequestTime = System.currentTimeMillis()
    }
}

/**
 * å¥—ç‰Œä»·æ ¼ä¿¡æ¯
 */
data class DeckPriceInfo(
    val totalPrice: Double,
    val averageCardPrice: Double,
    val topExpensiveCards: List<CardPriceInfo>,
    val currency: String
)

/**
 * å¡ç‰Œä»·æ ¼ä¿¡æ¯
 */
data class CardPriceInfo(
    val cardName: String,
    val price: Double,
    val lowPrice: Double = 0.0,
    val trendPrice: Double = 0.0,
    val currency: String,
    val timestamp: Long
)
```

---

### 2.4.3 ä»·æ ¼ UI

```kotlin
/**
 * ä»·æ ¼ä¿¡æ¯ç•Œé¢
 */
@AndroidEntryPoint
class PriceFragment : Fragment() {

    private val viewModel: DeckDetailViewModel by viewModels()
    private var _binding: FragmentPriceBinding? = null
    private val binding get() = _binding!!

    private lateinit var expensiveCardsAdapter: ExpensiveCardsAdapter

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentPriceBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        setupRecyclerView()
        observeData()
    }

    private fun setupRecyclerView() {
        expensiveCardsAdapter = ExpensiveCardsAdapter()

        binding.rvExpensiveCards.apply {
            layoutManager = LinearLayoutManager(requireContext())
            adapter = expensiveCardsAdapter
        }
    }

    private fun observeData() {
        viewLifecycleOwner.lifecycleScope.launch {
            viewModel.deckPriceInfo.collect { priceInfo ->
                priceInfo?.let { updateUI(it) }
            }
        }
    }

    private fun updateUI(priceInfo: DeckPriceInfo) {
        // æ€»ä»·æ ¼
        binding.tvTotalPrice.text = formatPrice(priceInfo.totalPrice, priceInfo.currency)

        // å¹³å‡ä»·æ ¼
        binding.tvAveragePrice.text = formatPrice(priceInfo.averageCardPrice, priceInfo.currency)

        // æœ€è´µçš„å¡ç‰Œ
        expensiveCardsAdapter.submitList(priceInfo.topExpensiveCards)
    }

    private fun formatPrice(price: Double, currency: String): String {
        return when (currency) {
            "EUR" -> "â‚¬${"%.2f".format(price)}"
            "USD" -> "$${"%.2f".format(price)}"
            "CNY" -> "Â¥${"%.2f".format(price)}"
            else -> "${"%.2f".format(price)} $currency"
        }
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }

    companion object {
        fun newInstance() = PriceFragment()
    }
}

/**
 * æœ€è´µå¡ç‰Œé€‚é…å™¨
 */
class ExpensiveCardsAdapter : RecyclerView.Adapter<ExpensiveCardsAdapter.ViewHolder>() {

    private var items = listOf<CardPriceInfo>()

    fun submitList(newItems: List<CardPriceInfo>) {
        items = newItems
        notifyDataSetChanged()
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val view = LayoutInflater.from(parent.context)
            .inflate(R.layout.item_expensive_card, parent, false)
        return ViewHolder(view)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        holder.bind(items[position])
    }

    override fun getItemCount(): Int = items.size

    class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
        fun bind(item: CardPriceInfo) {
            itemView.findViewById<TextView>(R.id.tvCardName).text = item.cardName
            itemView.findViewById<TextView>(R.id.tvPrice).text =
                "â‚¬${"%.2f".format(item.price)}"
        }
    }
}
```

---

## ğŸ“‹ æµ‹è¯•æ¸…å•

### æ³•æœ¯åŠ›æ›²çº¿æµ‹è¯•
- [ ] æ•°æ®ç‚¹è®¡ç®—æ­£ç¡®
- [ ] å›¾è¡¨æ˜¾ç¤ºæ­£ç¡®
- [ ] ç‚¹å‡»äº¤äº’æ­£å¸¸
- [ ] å»ºè®®ç”Ÿæˆåˆç†

### é¢œè‰²åˆ†å¸ƒæµ‹è¯•
- [ ] é¢œè‰²ç»Ÿè®¡å‡†ç¡®
- [ ] é¥¼å›¾æ˜¾ç¤ºæ­£ç¡®
- [ ] ç™¾åˆ†æ¯”è®¡ç®—æ­£ç¡®

### ä»·æ ¼ä¼°ç®—æµ‹è¯•
- [ ] API è°ƒç”¨æˆåŠŸ
- [ ] ä»·æ ¼è®¡ç®—å‡†ç¡®
- [ ] ç¼“å­˜æœºåˆ¶æœ‰æ•ˆ
- [ ] è¯·æ±‚é¢‘ç‡é™åˆ¶æ­£ç¡®

---

**åˆ›å»ºæ—¥æœŸï¼š** 2026-01-31
**ç›®æ ‡ç‰ˆæœ¬ï¼š** v4.2.0
**é¢„è®¡å®Œæˆï¼š** 3 å‘¨
