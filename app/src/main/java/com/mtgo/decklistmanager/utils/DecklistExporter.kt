package com.mtgo.decklistmanager.utils

import android.content.Context
import android.content.Intent
import android.net.Uri
import androidx.core.content.FileProvider
import com.mtgo.decklistmanager.domain.model.Card
import com.mtgo.decklistmanager.domain.model.CardLocation
import com.mtgo.decklistmanager.domain.model.Decklist
import com.google.gson.Gson
import com.google.gson.GsonBuilder
import java.io.File
import java.text.SimpleDateFormat
import java.util.*

/**
 * Export utility for decklists
 */
class DecklistExporter(private val context: Context) {

    private val gson: Gson = GsonBuilder().setPrettyPrinting().create()

    /**
     * Export decklist to text format
     */
    fun exportToText(decklist: Decklist, cards: List<Card>): Uri? {
        try {
            val fileName = "${decklist.eventName.replace(" ", "_")}_${decklist.date}.txt"
            val file = File(context.getExternalFilesDir(null), fileName)

            val content = buildString {
                appendLine("===========================================")
                appendLine(decklist.eventName)
                appendLine("===========================================")
                appendLine()
                appendLine("Format: ${decklist.format}")
                appendLine("Date: ${decklist.date}")
                appendLine("Player: ${decklist.playerName ?: "N/A"}")
                appendLine("Record: ${decklist.record ?: "N/A"}")
                appendLine()

                val mainDeck = cards.filter { it.location == CardLocation.MAIN }
                val sideboard = cards.filter { it.location == CardLocation.SIDEBOARD }

                if (mainDeck.isNotEmpty()) {
                    appendLine("Main Deck (${mainDeck.size}):")
                    appendLine("-------------------------------------------")
                    mainDeck.sortedBy { it.cardOrder }.forEach { card ->
                        appendLine("${card.quantity}x ${card.cardName}")
                        if (!card.manaCost.isNullOrEmpty()) {
                            appendLine("   ${card.manaCost}")
                        }
                    }
                    appendLine()
                }

                if (sideboard.isNotEmpty()) {
                    appendLine("Sideboard (${sideboard.size}):")
                    appendLine("-------------------------------------------")
                    sideboard.sortedBy { it.cardOrder }.forEach { card ->
                        appendLine("${card.quantity}x ${card.cardName}")
                        if (!card.manaCost.isNullOrEmpty()) {
                            appendLine("   ${card.manaCost}")
                        }
                    }
                }

                appendLine()
                appendLine("===========================================")
                appendLine("Generated by MTGO Decklist Manager")
                appendLine("===========================================")
            }

            file.writeText(content)
            return getFileUri(file)
        } catch (e: Exception) {
            e.printStackTrace()
            return null
        }
    }

    /**
     * Export decklist to JSON format
     */
    fun exportToJSON(decklist: Decklist, cards: List<Card>): Uri? {
        try {
            val fileName = "${decklist.eventName.replace(" ", "_")}_${decklist.date}.json"
            val file = File(context.getExternalFilesDir(null), fileName)

            val exportData = mapOf(
                "decklist" to mapOf(
                    "eventName" to decklist.eventName,
                    "eventType" to decklist.eventType,
                    "format" to decklist.format,
                    "date" to decklist.date,
                    "url" to decklist.url,
                    "playerName" to decklist.playerName,
                    "playerId" to decklist.playerId,
                    "record" to decklist.record,
                    "createdAt" to decklist.createdAt
                ),
                "mainDeck" to cards.filter { it.location == CardLocation.MAIN }
                    .sortedBy { it.cardOrder }
                    .map { cardToMap(it) },
                "sideboard" to cards.filter { it.location == CardLocation.SIDEBOARD }
                    .sortedBy { it.cardOrder }
                    .map { cardToMap(it) },
                "exportedAt" to SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault())
                    .format(Date())
            )

            val json = gson.toJson(exportData)
            file.writeText(json)

            return getFileUri(file)
        } catch (e: Exception) {
            e.printStackTrace()
            return null
        }
    }

    /**
     * Export all decklists to JSON
     */
    fun exportAllToJSON(decklists: List<Pair<Decklist, List<Card>>>): Uri? {
        try {
            val fileName = "all_decklists_${SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(Date())}.json"
            val file = File(context.getExternalFilesDir(null), fileName)

            val exportData = mapOf(
                "decklists" to decklists.map { (decklist, cards) ->
                    mapOf(
                        "decklist" to mapOf(
                            "eventName" to decklist.eventName,
                            "eventType" to decklist.eventType,
                            "format" to decklist.format,
                            "date" to decklist.date,
                            "url" to decklist.url,
                            "playerName" to decklist.playerName,
                            "playerId" to decklist.playerId,
                            "record" to decklist.record
                        ),
                        "mainDeck" to cards.filter { it.location == CardLocation.MAIN }
                            .sortedBy { it.cardOrder }
                            .map { cardToMap(it) },
                        "sideboard" to cards.filter { it.location == CardLocation.SIDEBOARD }
                            .sortedBy { it.cardOrder }
                            .map { cardToMap(it) }
                    )
                },
                "exportedAt" to SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault())
                    .format(Date())
            )

            val json = gson.toJson(exportData)
            file.writeText(json)

            return getFileUri(file)
        } catch (e: Exception) {
            e.printStackTrace()
            return null
        }
    }

    private fun cardToMap(card: Card): Map<String, Any?> {
        return mapOf(
            "cardName" to card.cardName,
            "quantity" to card.quantity,
            "manaCost" to card.manaCost,
            "rarity" to card.rarity,
            "color" to card.color,
            "cardType" to card.cardType,
            "cardSet" to card.cardSet
        )
    }

    private fun getFileUri(file: File): Uri {
        return FileProvider.getUriForFile(
            context,
            "${context.packageName}.fileprovider",
            file
        )
    }

    /**
     * Share exported file
     */
    fun shareFile(uri: Uri, mimeType: String = "text/plain") {
        val intent = Intent(Intent.ACTION_SEND).apply {
            type = mimeType
            putExtra(Intent.EXTRA_STREAM, uri)
            addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
        }

        context.startActivity(Intent.createChooser(intent, "Share decklist"))
    }

    /**
     * Open file with default app
     */
    fun openFile(uri: Uri, mimeType: String = "text/plain") {
        val intent = Intent(Intent.ACTION_VIEW).apply {
            setDataAndType(uri, mimeType)
            addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
        }

        context.startActivity(intent)
    }
}
